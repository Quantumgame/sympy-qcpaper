<h1>Gate rules and circuit simplification</h1>

\begin{verbatim}
%load_ext sympyprinting
\end{verbatim}

\begin{verbatim}
from sympy import sqrt, symbols, Rational
from sympy import expand, Eq, Symbol, simplify, exp, sin
from sympy.physics.quantum import *
from sympy.physics.quantum.qubit import *
from sympy.physics.quantum.gate import *
from sympy.physics.quantum.grover import *
from sympy.physics.quantum.qft import QFT, IQFT, Fourier
from sympy.physics.quantum.circuitplot import circuit_plot
from sympy.physics.quantum.gaterules import *
\end{verbatim}

The computational cost of a quantum algorithm is related to the number of gates
in the circuit that implements that algorithm. Just like a classical computer,
we would like to reduce the computational cost by <em>optimizing</em> the
circuit. This can be done by searching for relationships (or "rules") between
gates. Many such rules exist, but so far, there has been little work done to
find, classify and use these rules in a systematic way.<br><br> SymPy's symbolic
capabilities are perfect for this work as we don't have to represent the gates
as $2^N\times2^N$ dimensional matrices.

Find circuits equivalent to the Hadamard gate

\begin{verbatim}
h0 = match_gate_rules(H(0))
for rule in h0:
    display(Eq(H(0),rule))
\end{verbatim}

Find circuits equivalent to the Z gate

\begin{verbatim}
z0 = match_gate_rules(Z(0))
for rule in z0:
    display(Eq(Z(0),rule))
\end{verbatim}

Find circuits equivalent to the X gate

\begin{verbatim}
x0 = match_gate_rules(X(0))
for rule in x0:
    display(Eq(X(0),rule))
\end{verbatim}

Display a CNOT gate

\begin{verbatim}
circuit_plot(CNOT(1,0), nqubits=2)

\end{verbatim}

Find and display a circuit equivalent to the CNOT gate

\begin{verbatim}
c10 = match_gate_rules(CNOT(1,0))
\end{verbatim}

\begin{verbatim}
circuit_plot(c10[8], nqubits=2)
\end{verbatim}

\begin{verbatim}
%notebook save gate_rules.ipynb
\end{verbatim}

\begin{verbatim}

\end{verbatim}

